# Chapter_1 정리

## 1. 헤더파일
- C++의 표준 헤더파일 선언은 확장자인 .h를 생략한다.
- #include \<iostream.h>는 과거의 표준 입출력 라이브러리를 의미한다.
- #include \<iostream>은 새로운 표준 입출력 라이브러리를 의미한다.
+ C++ 컴파일러는 점차 \<iostream.h>를 지원하지 않는 추세로 접어들었다.


## 2. std::cout과 << 연산자를 이용한 출력
- 기본 형태는 std::cout << '출력대상'; 
- <<도 사실 연산자다.
- 별도의 출력 포맷 없이 데이터의 성격에 따라 적절한 출력이 이뤄진다.
- 연속적인 데이터 출력이 가능하다.


## 3. std::cin과 >> 연산자를 이용한 입력
- 기본 형태는 std::cin >> '입력대상';
- \>>도 마찬가지로 연산자다.
- 별도의 입력 포맷이 필요하지 않다.
- 연속적인 데이터 입력이 가능하다. ( 탭, 스페이스 바, 엔터와 같은 공백에 의해 나눠진다. )


## 4. C++의 지역변수 선언
- 지역변수 선언은 함수 내 어디든 삽입 가능하다.
- 3번과 4번의 특징을 활용해 for( int i = 0 ; i < myValue ; ++i ) 와 같은 표현이 가능하다.


## 5. 함수 오버로딩
- 동일한 이름의 함수를 인자를 다르게해서 선언하는 것을 말한다.
- 함수의 오버로딩이 가능 하려면, 매개변수의 선언이 달라야 한다.
- 반환 형식만 다른 경우 함수의 오버로딩이 불가능하다.
- int MyFunction( int num1 )과, int MyFunction( int num1, int num2 )는 다른 함수다.
- 이것이 가능한 이유는, C++은 함수를 호출할 때, 함수의 이름과 매개변수의 선언을 기준으로 찾기 때문이다.


## 6. 매개변수의 디폴트 값
- 함수 선언시, 매개 변수에 디폴트 값을 지정하여 전달 받은 값이 없는경우, 디폴트 값을 전달한것으로 간주한다.
- int MyFunction( int num, int num2=7 )로 선언되어 있는 경우, MyFunction(1) 은 1과, 7이 전달된것으로 간주한다.
- _함수의 인자는 좌측에서 우측으로 채워지도록 선언되어야 한다. int MyFunction( int num=1, int num2 )는 사용이 불가능하다._
- 함수의 선언이 별도로 필요한 경우, 디폴트 값은 함수의 원형 선언에만 위치해야 한다.

### 6번 궁금한 점
1. 함수의 default 값을 constant로 선언하고, 매개변수를 전달했을 때


## 7. 매크로 함수
- #define SUM(X, Y) ( (X) + (Y) ) 와 같이 선언한다.
- 일반 함수와 달리, 단순 치환만을 해준다. ( SUM(5, 6)을 호출한 경우, 5 + 6 으로 대체되어 사용된다. )
- 실행속도에 이점이 있으나, 복잡한 함수를 매크로의 형태로 정의하는데 한계가 있다. ( 정의하기 어렵다. )

### 7-1. C 언어에서의 함수
- C언어와 같이 구조화된 언어에서는 소스코드 중복을 줄이고, 코드의 재사용성을 높이기 위해 함수라는 개념을 제공한다.
- 함수는 호출될 때 스택 프레임이 일어나기 때문에 속도가 느려지는 단점이 있다.
- 위 특징은 매크로 함수를 사용하는 이유가 된다.

### 7-2. 매크로 함수의 특징
- 함수처럼 구현하지만, 대체되는 특징을 사용해 직접 코딩한것 처럼 처리해준다.
- 위의 이유로 매크로 함수는 스택 프레임을 사용하지 않는다. 그래서 속도가 빠르다.
- 하지만 스택 프레임을 사용하지 않기 때문에, 재귀호출 구조를 만들 수 없다.

### 7-3. 매크로 함수 KEY
- 함수는 코드의 재사용성을 높이지만, 함수를 위한 공간 할당(스택 프레임)이 발생하여 실행 속도가 느리다.
- 매크로 함수는 함수의 특징을 갖지만, 스택 프레임을 사용하지 않고 대체되는 방식을 통해 사용된다.
- 매크로 함수는 스택 프레임을 사용하지 않기 때문에 재귀호출 구조가 불가능하다.
- _매크로 함수의 inline화는 전처리기에 의해서 처리된다._


## 8. 인라인 함수
- 매크로 함수의 장점은 살리고, 단점은 제거한 함수 정의 방법이다.
- inline 키워드를 통해 선언한다.
- 매크로 함수와 달리 함수와 동일하게 사용할 수 있으며, 전처리기가 아닌 컴파일러에 의해 처리된다.
- 컴파일러의 판단에 성능에 해가 된다면 inline 코드를 무시하거나 inline으로 처리하기도 한다.
- 매크로와 달리 인라인 함수는 자료형에 의존적이지만, 템플릿을 통해 자료형에 의존적이지 않은 함수 선언이 가능하다.


## 9. 이름 공간(namespace)
- 같은 이름의 함수가 선언된 경우, 이름 공간을 나눠 각 각의 이름공간에 이름이 같은 함수를 선언하여 다른 함수로 사용할 수 있다.
```C++
namespace A {
  int MyFunction ( int num ) {...}
}

namespace B {
  int MyFunction ( int num ) {...}
}
```
- 호출은 A::MyFunction(1) 과 같은 방식으로 호출한다.
- ::는 범위지정 연산자다.
- std::cout, std::cin, std::endl 는 각 각 std 이름공간 내 선언되었다는것을 알 수 있다.
- 이름 공간은 다른 이름공간 안에 삽입될 수 있다. (중첩이 가능하다.)
- AAA::BBB::CCC 와 같이 중첩 호출이 가능하다.
- namespace ABC = AAA::BBB::CCC로 선언하면, AAA::BBB::CCC를 ABC::로 대체 가능하다.

### 9-1. 범위지정 연산자의 또 다른 기능
- 전역 변수는, 지역 변수보다 우선순위가 낮아 같은 이름의 전역변수는 무시되는 상황이 생긴다.
- 이 때, 전역 변수를 사용하기 위해 범위지정 연산자를 사용한다.
```C++
int val = 100;

int MyFunction( void ) {
  int val = 20;
  std::cout << val << std::endl; // 20
  std::cout << ::val << std::endl; // 100
}
```


## 10. using
- 이름 공간을 지정하지 않고 호출하겠다는 키워드다.
- using MyNameSpace::MyFunction 으로 선언하며, 이름 공간 없이 MyFunction 호출이 가능해진다.
- 지역변수와 마찬가지로 선언된 지역을 벗어나면 효력이 없다.

### 10-1. using namespace '이름 공간'
- 이름 공간에 선언된 모든 것에 대해 이름 공간 지정의 생략한다는 의미이다.
- using namespace std의 경우, cin >>, cout << 과 같이 이름 공간 지정없이 사용 가능하다.
- 프로그래밍 하기에 편해지나, 이름충돌이 발생할 확률이 상대적으로 높아진다.
- 상황을 판단해서 적절히 혼용하는 지혜가 필요하다.
