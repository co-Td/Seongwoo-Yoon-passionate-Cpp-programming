# 4. 정보 은닉
## 1. 좋은 클래스
좋은 클래스가 되기 위한 조건으로는 정보은닉과 캡슐화가 있다.  
  
- 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 한다.
- 실수가 쉽게 발견되어야 한다.
- 프로그래머의 실수에 대한 대책이 준비되어 있어야 한다.

### 좋은 클래스가 되기 위한 기본조건
- 멤버변수를 private으로 선언
- 해당 변수에 접근하는 함수를 별도로 정의

위 두 사항을 정보은닉이라 한다.

## 2. 정보은닉
멤버변수를 private으로 두고, 멤버 변수에 접근하기위한 함수를 별도로 정의하는것을 의미한다.
  
- 멤버 변수에 접근하기 위한 함수를 엑세스 함수라 한다.
- 엑세스 함수의 경우, 정의는 되었으나, 호출되지 않는 경우도 많다.  
(당장은 필요하지 않지만, 필요할 수 있따고 판단되는 함수들도 더불어 멤버에 포함시키는 경우도 많다. 대표적인 예가 엑세스 함수다.)


## 3. const 함수
___이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다!___

- const 함수 내에서는 const가 아닌 함수의 호출이 제한된다. 따라서 const 참조자를 이용한 경우, const 함수만 호출 가능하다.
- const 함수를 적절히 사용하면, 작성한 코드의 안정성이 높아진다.


## 4. 캡슐화
캡슐화는 콘택600 코감기약에 비유할 수 있다.  
콘택600은 재채기, 콧물, 코막힘의 완화를 제공하는데, 이 때 재채기 약, 콧물 약, 코막힘 약 이 세 종류를 먹는다면, 이것은 캡슐화가 성립하지 않는 상황이다.
콘택600 캡슐 하나로 코감기의 완화라는 하나의 목적 하에 둘 이상의 기능이 모여서 하나의 목적을 달성하고있어 이것을 캡슐화의 대표적인 예로 볼 수 있다.  

캡슐화는 단순히 하나의 기능을 묶는것이 아니다. 만약 다음과 같은 조건이 생긴다면 캡슐화는 큰 효과를 발휘한다.  
___약의 복용은 반드시 재채기 약, 콧물 약, 코막힘 약 순서대로 복용해야 한다.___ 
이 경우 순서가 바뀌면 부작용(버그)라는 결과가 발생할 수 있으나, 캡슐화를 통해 지정해 놓는다면 순서가 바뀔 이유가 없다.

### 캡슐화는 모든 기능을 넣는것이 좋은가?
- __캡슐화는 어려운 개념이다. 왜냐하면 캡슐화의 범위를 결정하는 일이 쉽지 않기 때문이다.__  
- __정보를 은닉시키기는 쉽다. 그러나 캡슐화는 어렵다.__  

콘택600을 통해 다시 예시를 들어 기침, 몸살, 두통까지 기능이 필요해 이 셋을 캡슐화를 한다면, 이것은 캡슐화가 적절히 이뤄지지 않은 클래스로 평가받을 수 있다.  
콘택600을 제외한 기침, 몸살, 두통을 해결하는 ___새로운 클래스가 항상 필요___ 하거나, 콘택600이 종합 감기약으로 거듭나야 하기 때문이다.  

### 캡슐화는 정보은닉이 기본적으로 포함된다.
캡슐화는 감싸는 개념이다. 그런데, 감싸려면 안전하게 감싸야 한다.  
다시말해 멤버변수가 보이지 않게 정보를 은닉해서 감싸는 것이 좋다. 그래서 캡슐화는 기본적으로 정보은닉을 포함하는 개념이라고도 이야기한다.


## 5. 생성자와 소멸자
### 1. 생성자
- 객체의 생성과 동시에 초기화를 할 수 있다.
- 객체 생성시 딱 한 번 호출된다.
- 생성자도 함수의 일종이라 ___오버로딩이___ 가능하다.
- 생성자도 함수의 일종이니 ___매개변수에 '디폴트 값'을 설정할 수 있다.___  
- 생성자가 클래스 내 없는경우, default constructor가 자동으로 삽입되어 호출된다. 따라서 생성자는 반드시 호출된다.

### 2. 멤버 이니셜라이저를 이용한 멤버 초기화
- 클래스 객체를 생성하면서, 클래스 내 선언된 멤버 객체도 초기화할 수 있는 기능을 제공한다.  
- 객체 뿐 아니라, const, 참조자도 초기화 가능하다. 즉 멤버 변수로 const와 참조자 선언이 가능해진다.

- 멤버 이니셜라이저 예시
```C++
class Rectangle {
  private:
    Point upLeft;
    Point lowRight;
  public:
    Rectangle(const int &x1, const int &y1, const int &x2, const int &y2);
    void ShowRecInfo() const;
}

Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
  :upLeft(x1, y1), lowRight(x2, y2) // 멤버 이니셜라이저 부분
{
  // Constructor body
}
```

### 3. 객체 생성과정 정리
1. 메모리 공간의 할당
2. 이니셜라이저를 통한 멤버변수(객체)의 초기화
3. 생성자의 몸체부분 실행

### 4. 디폴트 생성자(Default Constructor)
___객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.___   
위 내용을 만족하기 위해 생성자가 없는 경우 자동으로 삽입되는 생성자가 디폴트 생성자다.

- 디폴트 생성자 예시
```C++
class AAA{
  private:
    int num;
  public:
    AAA() {}
    int GetNum { return num; }
}

int main(void){
  AAA * ptr = new AAA;
  AAA * ptr = (AAA)malloc(sizeof(AAA));
};
```

### 5. 생성자 불일치
위에서 설명한 디폴트 생성자는 선언된 생성자가 없는 경우에만 삽입된다.  
생성자 불일치는 생성자에 필요한 파라미터 형식이 일치하지 않는경우 발생한다.

```C++
class SoSimple{
  private:
    int num;
  public:
    SoSimple(int n) : num(n) { }
};

int main(void){
  SoSimple simObj1(10);                 // (O)
  SoSimple * simPtr1 = new SoSimple(2); // (O)
  SoSimple simObj2;                     // (X)
  SoSimple * simPtr2 = new SoSimple;    // (X)
}
```

### 6. private 생성자
클래스 내부에 public이 아닌, private으로 생성자를 선언할 수 있다.  
외부에서 접근할 순 없지만, ___클래스 내부에서만 객체를 생성___ 하려 할 때 사용된다.  

- 예시
```C++
class SoSimple{
  private:
    int num;
    char ch;
  public:
    SoSimple(int n) : num(n) { }
  private:
    SoSimple(char c) : ch(a) {} // private 생성자
};
```


### 7. 소멸자
- 객체 소멸시 반드시 호출되는 메서드를 말한다. 형태는 클래스의 이름 앞에 ~가 붙은 형태다.
- 반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
- 매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정두 불가능하다.

- 소멸자는 객체소멸 과정(delete) 과정에서 자동으로 호출이 된다.  
프로그래머가 따로 소멸자를 정의하지 않으면, 디폴트 소멸자가 자동으로 삽입된다.  

```C++
class AAA{
  // empty function
}

// 아래 클래스와 동일하다.

class AAA{
  public: 
    AAA(){} // 자동 삽입된 디폴트 생성자
    ~AAA(){} // 자동 삽입된 디폴트 소멸자
}
```

소멸자에서는 delete 연산자를 이용해 이 메모리 공간을 소멸한다.
소멸자를 통해서 객체소멸과정에서 처리해야 할 일들을 자동으로 처리할 수 있다.


## 6. 클래스와 배열 그리고 this 포인터
배열을 선언하는 경우에도 생성자는 호출된다.
단 배열의 선언 과정에서는 생성자를 별도로 명시할 수 없다. 
즉, 위의 형태로 배열이 생성되려면 다음 형태의 생성자가 반드시 정의되어 있어야 한다.

```C++
class AAA{
  public:
    AAA() {}
}
```

### 1. 객체 포인터 배열
객체 포인터 배열은 객체의 주소 값 저장이 가능한 포인터 변수로 이뤄진 배열이다.  
예시)
```C++
  MyClass *myClassArr[3];
```

### 2. 객체 배열 vs 객체 포인터 배열
```C++
  // 객체 배열
  MyClass myClassArr = new MyClass[10];
  
  // 객체 포인터 배열
  MyClass *myClassArr[10];
```
객체 배열의 경우 객체 자체를 저장하는 배열을 의미하고,   
객체 포인터 배열의 경우 객체를 가리킬 수 있는 포인터를 원소로 하는 배열을 의미한다.

### 3. this 포인터의 이해
- 객체 자신을 가리키는 용도로 사용되는 포인터다.  
- this는 객체자신의 주소 값을 의미한다.

### 4. Self-Reference의 반환
객체 자신을 참조할 수 있는 참조자를 의미한다.

```C++
class SelfRef{
  private:
    int num;
  public:
    SelfRef(int n) : num(n){
      std::cout << "객체 생성" << std::endl;
    }
    SelfRef& Adder(int n) {
      this->num += n;
      return *this;
    }
    SelfRef& ShowTwoNumber(){
      std::cout << this->num << std::endl;
      return *this;
    }
};d
```

