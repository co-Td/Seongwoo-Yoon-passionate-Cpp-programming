# 4. 정보 은닉
## 1. 좋은 클래스
좋은 클래스가 되기 위한 조건으로는 정보은닉과 캡슐화가 있다.  
  
- 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 한다.
- 실수가 쉽게 발견되어야 한다.
- 프로그래머의 실수에 대한 대책이 준비되어 있어야 한다.

### 좋은 클래스가 되기 위한 기본조건
- 멤버변수를 private으로 선언
- 해당 변수에 접근하는 함수를 별도로 정의

위 두 사항을 정보은닉이라 한다.

## 2. 정보은닉
멤버변수를 private으로 두고, 멤버 변수에 접근하기위한 함수를 별도로 정의하는것을 의미한다.
  
- 멤버 변수에 접근하기 위한 함수를 엑세스 함수라 한다.
- 엑세스 함수의 경우, 정의는 되었으나, 호출되지 않는 경우도 많다.  
(당장은 필요하지 않지만, 필요할 수 있따고 판단되는 함수들도 더불어 멤버에 포함시키는 경우도 많다. 대표적인 예가 엑세스 함수다.)


## 3. const 함수
___이 함수 내에서는 멤버변수에 저장된 값을 변경하지 않겠다!___

- const 함수 내에서는 const가 아닌 함수의 호출이 제한된다. 따라서 const 참조자를 이용한 경우, const 함수만 호출 가능하다.
- const 함수를 적절히 사용하면, 작성한 코드의 안정성이 높아진다.


## 4. 캡슐화
캡슐화는 콘택600 코감기약에 비유할 수 있다.  
콘택600은 재채기, 콧물, 코막힘의 완화를 제공하는데, 이 때 재채기 약, 콧물 약, 코막힘 약 이 세 종류를 먹는다면, 이것은 캡슐화가 성립하지 않는 상황이다.
콘택600 캡슐 하나로 코감기의 완화라는 하나의 목적 하에 둘 이상의 기능이 모여서 하나의 목적을 달성하고있어 이것을 캡슐화의 대표적인 예로 볼 수 있다.  

캡슐화는 단순히 하나의 기능을 묶는것이 아니다. 만약 다음과 같은 조건이 생긴다면 캡슐화는 큰 효과를 발휘한다.  
___약의 복용은 반드시 재채기 약, 콧물 약, 코막힘 약 순서대로 복용해야 한다.___ 
이 경우 순서가 바뀌면 부작용(버그)라는 결과가 발생할 수 있으나, 캡슐화를 통해 지정해 놓는다면 순서가 바뀔 이유가 없다.

### 캡슐화는 모든 기능을 넣는것이 좋은가?
- __캡슐화는 어려운 개념이다. 왜냐하면 캡슐화의 범위를 결정하는 일이 쉽지 않기 때문이다.__  
- __정보를 은닉시키기는 쉽다. 그러나 캡슐화는 어렵다.__  

콘택600을 통해 다시 예시를 들어 기침, 몸살, 두통까지 기능이 필요해 이 셋을 캡슐화를 한다면, 이것은 캡슐화가 적절히 이뤄지지 않은 클래스로 평가받을 수 있다.  
콘택600을 제외한 기침, 몸살, 두통을 해결하는 ___새로운 클래스가 항상 필요___ 하거나, 콘택600이 종합 감기약으로 거듭나야 하기 때문이다.  

### 캡슐화는 정보은닉이 기본적으로 포함된다.
캡슐화는 감싸는 개념이다. 그런데, 감싸려면 안전하게 감싸야 한다.  
다시말해 멤버변수가 보이지 않게 정보를 은닉해서 감싸는 것이 좋다. 그래서 캡슐화는 기본적으로 정보은닉을 포함하는 개념이라고도 이야기한다.


## 5. 생성자와 소멸자
### 1. 생성자
- 객체의 생성과 동시에 초기화를 할 수 있다.
- 객체 생성시 딱 한 번 호출된다.
- 생성자도 함수의 일종이라 ___오버로딩이___ 가능하다.
- 생성자도 함수의 일종이니 ___매개변수에 '디폴트 값'을 설정할 수 있다.___  
- 생성자가 클래스 내 없는경우, default constructor가 자동으로 삽입되어 호출된다. 따라서 생성자는 반드시 호출된다.

### 2. 멤버 이니셜라이저를 이용한 멤버 초기화
- 클래스 객체를 생성하면서, 클래스 내 선언된 멤버 객체도 초기화할 수 있는 기능을 제공한다.  
- 객체 뿐 아니라, const, 참조자도 초기화 가능하다. 즉 멤버 변수로 const와 참조자 선언이 가능해진다.

- 멤버 이니셜라이저 예시
```C++
class Rectangle {
  private:
    Point upLeft;
    Point lowRight;
  public:
    Rectangle(const int &x1, const int &y1, const int &x2, const int &y2);
    void ShowRecInfo() const;
}

Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
  :upLeft(x1, y1), lowRight(x2, y2) // 멤버 이니셜라이저 부분
{
  // Constructor body
}
```

### 3. 객체 생성과정 정리
1. 메모리 공간의 할당
2. 이니셜라이저를 통한 멤버변수(객체)의 초기화
3. 생성자의 몸체부분 실행

### 4. 디폴트 생성자(Default Constructor)
___객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다.___   
위 내용을 만족하기 위해 생성자가 없는 경우 자동으로 삽입되는 생성자가 디폴트 생성자다.

- 디폴트 생성자 예시
```C++
class AAA{
  private:
    int num;
  public:
    AAA() {}
    int GetNum { return num; }
}

int main(void){
  AAA * ptr = new AAA;
  AAA * ptr = (AAA)malloc(sizeof(AAA));
};
```

### 5. 생성자 불일치
위에서 설명한 디폴트 생성자는 선언된 생성자가 없는 경우에만 삽입된다.  
생성자 불일치는 생성자에 필요한 파라미터 형식이 일치하지 않는경우 발생한다.

```C++
class SoSimple{
  private:
    int num;
  public:
    SoSimple(int n) : num(n) { }
};

int main(void){
  SoSimple simObj1(10);                 // (O)
  SoSimple * simPtr1 = new SoSimple(2); // (O)
  SoSimple simObj2;                     // (X)
  SoSimple * simPtr2 = new SoSimple;    // (X)
}
```

### 6. private 생성자
클래스 내부에 public이 아닌, private으로 생성자를 선언할 수 있다.  
외부에서 접근할 순 없지만, ___클래스 내부에서만 객체를 생성___ 하려 할 때 사용된다.  

- 예시
```C++
class SoSimple{
  private:
    int num;
    char ch;
  public:
    SoSimple(int n) : num(n) { }
  private:
    SoSimple(char c) : ch(a) {} // private 생성자
};
