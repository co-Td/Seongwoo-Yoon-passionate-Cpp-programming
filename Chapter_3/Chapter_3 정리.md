# Chpater_3 정리

## 구조체
- 연관 있는 데이터를 묶을 수 있는 문법적 장치
- C++은 구조체 내 함수 선언이 가능하다.
- 구조체 내 enum 상수 선언이 가능하다.
- 구조체 내 함수는 선언부와 정의부를 나눌 수 있다. (구조체를 보는 순간, 정의되어 있는 함수의 종류와 기능이 한눈에 들어오게끔 코드를 작성하는 것이 좋다.)
- 구조체 내 함수가 정의되어 있으면, 해당 함수를 인라인으로 처리하라는 의미가 내포된다. 하지만 구조체 외부에 함수를 정의하면 해당 의미는 사라진다.


## 클래스
- 접근제어 지시자
1. public       : 어디서든 접근 허용
2. protected    : 상속관계에 놓여있을 때, 유도 클래스에서의 접근 허용
3. private      : 클래스 내(클래스 내에 정의된 함수)에서만 접근 허용
```C++
// 클래스의 선언
int MyFunction();

// 클래스의 정의
int MyFunction() { 
  ...
}
```

## 클래스와 구조체의 차이점
- 겉으로 보이는 차이점
```C++
struct Car1{
  int speed;
  void accel();
}

class Car2{
  int speed;
  void accel();
}

int main(){
  Car1 car = { 10 };
  Car2 car = new Car2();
}
```
- 접근제어 지시자
구조체의 경우 접근제어 지시자 미선언은 public, 클래스는 private으로 인식한다.


## 레이블
접근제어 지시자의 뒤에는 세미콜론이 아닌 콜론이 붙는다. 이는 접근제어 지시자가 특정 위치정보를 알리는 레이블(라벨)이기 때문이다.  
switch문의 case도 마찬가지로 레이블이기 때문에 콜론이 붙는다.


## 멤버
클래스로 선언된 변수를 의미한다.
1. 멤버 변수: 클래스 내에 선언된 ___변수___ 를 의미한다.
2. 멤버 함수: 클래스 내에 선언된 ___함수___ 를 의미한다.


## 파일 분할
클래스의 선언, 클래스의 정의, 링커에 의해 묶인 하나의 실행파일 3개로 구성된다.

1. 인라인 함수는 헤더파일에 함께 넣어야 한다.
- 인라인 함수는 클래스의 선언과 동일한 파일에 저장되어서 컴파일러가 동시에 참조할 수 있게 해야한다.
- 컴파일러는 파일 단위로 컴파일을 한다.


## 객체지향 프로그래밍의 이해
### 1. 객체
- Object: 사물, 또는 대상

### 2. 객체의 이해
___객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화 시키는 형태의 프로그래밍이다.___

1. 예문으로 본 객체의 이해   
나는 과일장수에게 두 개의 사과를 구매했다!  

위의 예문에서 객체는 나, 사과장수, 사과가 된다.
___'나'___ 라는 객체는 ___'과일장수'___ 라는 객체로부터 ___'과일'___ 객체를 구매한것이 된다.

예문을 프로그래밍상에서 바라보는 관점은, ___과일의 판매___ 에 있다. 따라서 프로그램상에서 바라보는 과일장수는 다음과 같은 형태이다.  
1. 과일장수는 과일을 팝니다. (과일장수의 행동: behavior)
2. 과일장수는 사과 20개, 오렌지 10개를 보유하고 있습니다. (과일장수의 상태: state)
3. 과일장수의 과일판매 수익은 현재까지 50,000원 입니다. (과일장수의 상태: state)  
 
과일장수를 프로그래밍으로 표현하면,
```C++
class SaleApples {
  private:
    int apple;
    int orange;
    int money;
  public:
    void SellApple( int count ){ // behavior
      this->apple -= count;
      this->money += ( 1000 * count ); 
    }
    
    void SellOrange( int count ){ // behavior
      this->Orange -= count;
      this->money += ( 2000 * count ); 
    }
    
    void State(){ // state
      std::cout << "보유 사과: " << this->apple << std::endl;
      std::cout << "보유 오렌지: " << this->orange << std::endl;
      std::cout << "수익: " << this->money << std::endl;
    }
}
```

2. 객체간의 대화 방법(Message Passing 방법)  
위에 제시한 예문으로 살펴보면, 
- 과일장수 아저씨 사과 2000원어치 주세요  
위 내용은, 나 객체가, 과일장수 객체에게 메시지를 전달한것이다. (어떠한 행위의 요구를 위한 메시지 전달)  
객체지향에서는 이러한 형태의 함수호출을 가리켜 ___'메시지 전달 (Message Passing)'___ 이라 한다.
